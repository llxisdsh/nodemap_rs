# NodeMap 性能优化分析

## 问题诊断

### 性能差距
- NodeMap `with_capacity(100_000)`: 1.54ms
- DashMap `with_capacity(100_000)`: 25.2μs
- **性能差距: 61倍**

### 根本原因
1. **大块内存预分配**: NodeMap 为 100,000 容量预分配 32,768 个 bucket (4.25MB)
2. **零初始化开销**: 使用 `alloc_zeroed` 零初始化整个 4.25MB 内存
3. **浪费的初始化**: 大部分 bucket 可能永远不会被使用

### DashMap 的优势
- 分片架构: 使用多个小的 `RwLock<HashMap>`
- 延迟分配: 只在需要时分配内存
- 较小的初始内存占用

## 优化策略

### 策略 1: 延迟 Bucket 初始化
- 只分配 bucket 指针数组，不预分配 bucket 内容
- 在首次访问时才初始化具体的 bucket
- 减少初始化时的内存分配和零初始化

### 策略 2: 使用 alloc 替代 alloc_zeroed
- 对于不需要零初始化的字段，使用 `alloc` 而非 `alloc_zeroed`
- 手动初始化关键的原子字段 (meta, seq, next)
- 延迟初始化 entries 数组

### 策略 3: 分段初始化
- 将大的 bucket 数组分成多个段
- 只初始化第一段，其他段按需初始化
- 类似于 DashMap 的分片思想

### 策略 4: 内存布局优化
- 重新设计 Bucket 结构，减少内存占用
- 考虑使用更紧凑的数据结构
- 优化内存对齐

## 推荐实施顺序

1. **立即实施**: 策略 2 (alloc 替代 alloc_zeroed)
2. **中期实施**: 策略 1 (延迟 Bucket 初始化)
3. **长期考虑**: 策略 3 和 4 (架构重构)

## 预期效果

基于分析，策略 2 应该能带来显著改善：
- 减少零初始化 4.25MB 的开销
- 保持现有架构的简单性
- 预期性能提升: 30-50%